# let a : Nat = 1 + (2 + 3)
# let b : Nat = succ 1
# let c : Nat = ifz 0 then a else b
# let rec sum (m n : Nat) : Nat =
#     ifz n then m
#         else sum (succ m) (pred n)
# let ret : Nat = sum 5 2

let f (x : Nat) : Nat = succ x

let g (x : Nat) : Nat = succ x

let ret : Nat = f 0

let f = succ x in
    let g = succ x in
        let ret = f 0


__1(__clo2, __x0) {
Init:
  Assign (Temp "t0") (V (R (Temp "__x0")))
  Assign (Temp "t1") (UnOp Succ (R (Temp "t0")))
Return (R (Temp "t1"))
}

declare f

__4(__clo5, __x3) {
Init:
  Assign (Temp "t2") (MkClosure "__1" [])
  Store "f" (V (R (Temp "t2")))
  Assign (Temp "t3") (V (R (Temp "__x3")))
  Assign (Temp "t4") (UnOp Succ (R (Temp "t3")))
Return (R (Temp "t4"))
}

declare g

declare ret

pcfmain() {
Init:
  Assign (Temp "t5") (MkClosure "__4" [])
  Store "g" (V (R (Temp "t5")))
  Assign (Temp "__clo6") (V (G "f"))
  Assign (Temp "t6") (Access (R (Temp "__clo6")) 0)
  Assign (Temp "t7") (Call (R (Temp "t6")) [R (Temp "__clo6"),C 0])
  Store "ret" (V (R (Temp "t7")))
Return (R (Temp "t7"))
}


IrFun {irDeclName = "__1", irDeclArgNames = ["__clo2","__x0"], irDeclBody = IrUnaryOp Succ (IrVar "__x0")}
IrVal {irDeclName = "f", irDeclDef = MkClosure "__1" []}
IrFun {irDeclName = "__4", irDeclArgNames = ["__clo5","__x3"], irDeclBody = IrUnaryOp Succ (IrVar "__x3")}
IrVal {irDeclName = "g", irDeclDef = MkClosure "__4" []}
IrVal {irDeclName = "ret", irDeclDef = IrLet "__clo6" (IrVar "f") (IrCall (IrAccess (IrVar "__clo6") 0) [IrVar "__clo6",IrConst (CNat 0)])}